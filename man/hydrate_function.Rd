% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{hydrate_function}
\alias{hydrate_function}
\title{Hydrate a function's enclosing environment}
\usage{
hydrate_function(fun, ..., caller_env = parent.frame())
}
\arguments{
\item{fun}{(\code{function})}

\item{...}{additional variables to add to the new enclosure, see \code{Details}}

\item{caller_env}{(\code{environment}) environment to hydrate \code{fun}'s enclosure with}
}
\value{
A \code{function} which will work just like \code{fun} but in a different scope.
}
\description{
Add bindings of an environment to a function's parent environment.
}
\details{
This allows any funciton to use bindings present in any environment
as if the funciton were defined there.
All bindings of the additional environment are added to the function's enclosure,
except bindings existing in the enclosure are \emph{not} overwritten.

One may also want to add variables that are not bound in the caller
but are accessible from the caller, e.g. they exist in the caller's parent frame.
This may happen in \code{shiny} modules because \code{moduleServer} is called
by the module server function so the server funciton's arguments are in scope
of \code{moduleServer} but are not bindings in its environment.
Such variables should be passed to \code{...}.
As in the case of calling environment bindings, no overwriting will occur.

Variables passed to \code{...} ass \code{name:value} pairs will be assigned with \code{value} under \code{name}.
Variables passed directly will be assigned under the same name.

Note that the \code{caller_env} argument must be passed named, otherwise it will be captured by \code{...}.
}
\keyword{internal}
